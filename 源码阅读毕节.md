获取classloader  

```java
ClassLoader.getSystemClassLoader();
Thread.currentThread().getContextClassLoader(),
```

读取资源

```java
InputStream returnValue = cl.getResourceAsStream(resource);
```

Mybatis所有的配置都在Configuration对象上

SqlSessionFactory持有Configuration对象

SqlSessionFactory openSqlSession会从Configuration获取事务管理器

不配置默认ManagedTransactionFactory 可配置JdbcTransactionFactory

SqlSession里面有Executor类的引用 Executor里面有事务的引用，

核心数据库执行全靠Executor

一个Executor对应一个事务

一个事务对应数据库一个Connector

所以一个SqlSession不同时刻执行的时候都是同一个Connector

MapperScannerRegistrar 扫描mapper接口动态代理生成bean

MapperScannerConfigurer真正去生成mapper 需要指定basePackage

ClassPathMapperScanner 集成自 ClassPathBeanDefinitionScanner扫描basePackage下的接口注册成bean,最终代理类为MapperFactoryBean getObject返回MapperProxyFactory，MapperProxy进行动态代理

如果不开启spring事务 每一个mapper方法的执行都是用的默认的sqlSession

如果开启了事务  那么在一个事务内都共用一个Session，嵌套事务也会生成新的Session

SqlSessionSynchronization会在事务挂起 提交的几个阶段对session进行管理

Mapper里面的方法最终会被代理为MapperMethod

Mybatis的多参数都是通过map传递的参考ParamNameResolver#getNamedParams

一级缓存在Executor里面 二级缓存存在MappedStatement里面
